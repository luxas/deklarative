// Code generated by counterfeiter. DO NOT EDIT.
package tracingfakes

import (
	"sync"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

type FakeSpan struct {
	AddEventStub        func(string, ...trace.EventOption)
	addEventMutex       sync.RWMutex
	addEventArgsForCall []struct {
		arg1 string
		arg2 []trace.EventOption
	}
	EndStub        func(...trace.SpanEndOption)
	endMutex       sync.RWMutex
	endArgsForCall []struct {
		arg1 []trace.SpanEndOption
	}
	IsRecordingStub        func() bool
	isRecordingMutex       sync.RWMutex
	isRecordingArgsForCall []struct {
	}
	isRecordingReturns struct {
		result1 bool
	}
	isRecordingReturnsOnCall map[int]struct {
		result1 bool
	}
	RecordErrorStub        func(error, ...trace.EventOption)
	recordErrorMutex       sync.RWMutex
	recordErrorArgsForCall []struct {
		arg1 error
		arg2 []trace.EventOption
	}
	SetAttributesStub        func(...attribute.KeyValue)
	setAttributesMutex       sync.RWMutex
	setAttributesArgsForCall []struct {
		arg1 []attribute.KeyValue
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetStatusStub        func(codes.Code, string)
	setStatusMutex       sync.RWMutex
	setStatusArgsForCall []struct {
		arg1 codes.Code
		arg2 string
	}
	SpanContextStub        func() trace.SpanContext
	spanContextMutex       sync.RWMutex
	spanContextArgsForCall []struct {
	}
	spanContextReturns struct {
		result1 trace.SpanContext
	}
	spanContextReturnsOnCall map[int]struct {
		result1 trace.SpanContext
	}
	TracerProviderStub        func() trace.TracerProvider
	tracerProviderMutex       sync.RWMutex
	tracerProviderArgsForCall []struct {
	}
	tracerProviderReturns struct {
		result1 trace.TracerProvider
	}
	tracerProviderReturnsOnCall map[int]struct {
		result1 trace.TracerProvider
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpan) AddEvent(arg1 string, arg2 ...trace.EventOption) {
	fake.addEventMutex.Lock()
	fake.addEventArgsForCall = append(fake.addEventArgsForCall, struct {
		arg1 string
		arg2 []trace.EventOption
	}{arg1, arg2})
	stub := fake.AddEventStub
	fake.recordInvocation("AddEvent", []interface{}{arg1, arg2})
	fake.addEventMutex.Unlock()
	if stub != nil {
		fake.AddEventStub(arg1, arg2...)
	}
}

func (fake *FakeSpan) AddEventCallCount() int {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return len(fake.addEventArgsForCall)
}

func (fake *FakeSpan) AddEventCalls(stub func(string, ...trace.EventOption)) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = stub
}

func (fake *FakeSpan) AddEventArgsForCall(i int) (string, []trace.EventOption) {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	argsForCall := fake.addEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) End(arg1 ...trace.SpanEndOption) {
	fake.endMutex.Lock()
	fake.endArgsForCall = append(fake.endArgsForCall, struct {
		arg1 []trace.SpanEndOption
	}{arg1})
	stub := fake.EndStub
	fake.recordInvocation("End", []interface{}{arg1})
	fake.endMutex.Unlock()
	if stub != nil {
		fake.EndStub(arg1...)
	}
}

func (fake *FakeSpan) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeSpan) EndCalls(stub func(...trace.SpanEndOption)) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = stub
}

func (fake *FakeSpan) EndArgsForCall(i int) []trace.SpanEndOption {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	argsForCall := fake.endArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) IsRecording() bool {
	fake.isRecordingMutex.Lock()
	ret, specificReturn := fake.isRecordingReturnsOnCall[len(fake.isRecordingArgsForCall)]
	fake.isRecordingArgsForCall = append(fake.isRecordingArgsForCall, struct {
	}{})
	stub := fake.IsRecordingStub
	fakeReturns := fake.isRecordingReturns
	fake.recordInvocation("IsRecording", []interface{}{})
	fake.isRecordingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) IsRecordingCallCount() int {
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	return len(fake.isRecordingArgsForCall)
}

func (fake *FakeSpan) IsRecordingCalls(stub func() bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = stub
}

func (fake *FakeSpan) IsRecordingReturns(result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	fake.isRecordingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) IsRecordingReturnsOnCall(i int, result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	if fake.isRecordingReturnsOnCall == nil {
		fake.isRecordingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRecordingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) RecordError(arg1 error, arg2 ...trace.EventOption) {
	fake.recordErrorMutex.Lock()
	fake.recordErrorArgsForCall = append(fake.recordErrorArgsForCall, struct {
		arg1 error
		arg2 []trace.EventOption
	}{arg1, arg2})
	stub := fake.RecordErrorStub
	fake.recordInvocation("RecordError", []interface{}{arg1, arg2})
	fake.recordErrorMutex.Unlock()
	if stub != nil {
		fake.RecordErrorStub(arg1, arg2...)
	}
}

func (fake *FakeSpan) RecordErrorCallCount() int {
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	return len(fake.recordErrorArgsForCall)
}

func (fake *FakeSpan) RecordErrorCalls(stub func(error, ...trace.EventOption)) {
	fake.recordErrorMutex.Lock()
	defer fake.recordErrorMutex.Unlock()
	fake.RecordErrorStub = stub
}

func (fake *FakeSpan) RecordErrorArgsForCall(i int) (error, []trace.EventOption) {
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	argsForCall := fake.recordErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) SetAttributes(arg1 ...attribute.KeyValue) {
	fake.setAttributesMutex.Lock()
	fake.setAttributesArgsForCall = append(fake.setAttributesArgsForCall, struct {
		arg1 []attribute.KeyValue
	}{arg1})
	stub := fake.SetAttributesStub
	fake.recordInvocation("SetAttributes", []interface{}{arg1})
	fake.setAttributesMutex.Unlock()
	if stub != nil {
		fake.SetAttributesStub(arg1...)
	}
}

func (fake *FakeSpan) SetAttributesCallCount() int {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	return len(fake.setAttributesArgsForCall)
}

func (fake *FakeSpan) SetAttributesCalls(stub func(...attribute.KeyValue)) {
	fake.setAttributesMutex.Lock()
	defer fake.setAttributesMutex.Unlock()
	fake.SetAttributesStub = stub
}

func (fake *FakeSpan) SetAttributesArgsForCall(i int) []attribute.KeyValue {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	argsForCall := fake.setAttributesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNameStub
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if stub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *FakeSpan) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *FakeSpan) SetNameCalls(stub func(string)) {
	fake.setNameMutex.Lock()
	defer fake.setNameMutex.Unlock()
	fake.SetNameStub = stub
}

func (fake *FakeSpan) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	argsForCall := fake.setNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetStatus(arg1 codes.Code, arg2 string) {
	fake.setStatusMutex.Lock()
	fake.setStatusArgsForCall = append(fake.setStatusArgsForCall, struct {
		arg1 codes.Code
		arg2 string
	}{arg1, arg2})
	stub := fake.SetStatusStub
	fake.recordInvocation("SetStatus", []interface{}{arg1, arg2})
	fake.setStatusMutex.Unlock()
	if stub != nil {
		fake.SetStatusStub(arg1, arg2)
	}
}

func (fake *FakeSpan) SetStatusCallCount() int {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	return len(fake.setStatusArgsForCall)
}

func (fake *FakeSpan) SetStatusCalls(stub func(codes.Code, string)) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = stub
}

func (fake *FakeSpan) SetStatusArgsForCall(i int) (codes.Code, string) {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	argsForCall := fake.setStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) SpanContext() trace.SpanContext {
	fake.spanContextMutex.Lock()
	ret, specificReturn := fake.spanContextReturnsOnCall[len(fake.spanContextArgsForCall)]
	fake.spanContextArgsForCall = append(fake.spanContextArgsForCall, struct {
	}{})
	stub := fake.SpanContextStub
	fakeReturns := fake.spanContextReturns
	fake.recordInvocation("SpanContext", []interface{}{})
	fake.spanContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) SpanContextCallCount() int {
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	return len(fake.spanContextArgsForCall)
}

func (fake *FakeSpan) SpanContextCalls(stub func() trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = stub
}

func (fake *FakeSpan) SpanContextReturns(result1 trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	fake.spanContextReturns = struct {
		result1 trace.SpanContext
	}{result1}
}

func (fake *FakeSpan) SpanContextReturnsOnCall(i int, result1 trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	if fake.spanContextReturnsOnCall == nil {
		fake.spanContextReturnsOnCall = make(map[int]struct {
			result1 trace.SpanContext
		})
	}
	fake.spanContextReturnsOnCall[i] = struct {
		result1 trace.SpanContext
	}{result1}
}

func (fake *FakeSpan) TracerProvider() trace.TracerProvider {
	fake.tracerProviderMutex.Lock()
	ret, specificReturn := fake.tracerProviderReturnsOnCall[len(fake.tracerProviderArgsForCall)]
	fake.tracerProviderArgsForCall = append(fake.tracerProviderArgsForCall, struct {
	}{})
	stub := fake.TracerProviderStub
	fakeReturns := fake.tracerProviderReturns
	fake.recordInvocation("TracerProvider", []interface{}{})
	fake.tracerProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) TracerProviderCallCount() int {
	fake.tracerProviderMutex.RLock()
	defer fake.tracerProviderMutex.RUnlock()
	return len(fake.tracerProviderArgsForCall)
}

func (fake *FakeSpan) TracerProviderCalls(stub func() trace.TracerProvider) {
	fake.tracerProviderMutex.Lock()
	defer fake.tracerProviderMutex.Unlock()
	fake.TracerProviderStub = stub
}

func (fake *FakeSpan) TracerProviderReturns(result1 trace.TracerProvider) {
	fake.tracerProviderMutex.Lock()
	defer fake.tracerProviderMutex.Unlock()
	fake.TracerProviderStub = nil
	fake.tracerProviderReturns = struct {
		result1 trace.TracerProvider
	}{result1}
}

func (fake *FakeSpan) TracerProviderReturnsOnCall(i int, result1 trace.TracerProvider) {
	fake.tracerProviderMutex.Lock()
	defer fake.tracerProviderMutex.Unlock()
	fake.TracerProviderStub = nil
	if fake.tracerProviderReturnsOnCall == nil {
		fake.tracerProviderReturnsOnCall = make(map[int]struct {
			result1 trace.TracerProvider
		})
	}
	fake.tracerProviderReturnsOnCall[i] = struct {
		result1 trace.TracerProvider
	}{result1}
}

func (fake *FakeSpan) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	fake.tracerProviderMutex.RLock()
	defer fake.tracerProviderMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSpan) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ trace.Span = new(FakeSpan)
